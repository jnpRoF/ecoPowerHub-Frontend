{
  "language": "Solidity",
  "sources": {
    "contracts/ServiceMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ServiceMarketplace\n/// @author olaoye salem\n/// @notice This smart contract is a  factory that will always be deployed by companies. \n/// @notice This contract allow users to invest in companies and participate in the revenue sharing. \n\n\ncontract ServiceMarketplace {\n    address public owner;\n    uint256 public totalCompanyValue;  // Total value of the company\n    uint256 public totalShares;    \n    uint256 public sharePrice;// Price per share in toro\n    uint256 public constantShare; \n\n    struct Investor {\n        uint256 investedAmount;\n        uint256 sharePercentage;\n    }\n\n    /** EVENTS */\n    event newInvestor( address indexed investor,  uint256 indexed percentage);\n    event ServicePaymentProcessed( uint256 indexed amountPaid);\n    event withdrawSuccess( uint256 indexed amount , address indexed addressTo );\n\n    \n\n    mapping(address => Investor) public investors; // Map of investors and their investments\n    address[] public investorAddresses;  // List of investor addresses\n\n    constructor(uint256 _totalCompanyValue, uint256 _totalShares, uint256 _sharePrice ) {\n        owner = msg.sender;\n        totalCompanyValue = _totalCompanyValue;\n        totalShares = _totalShares;\n        constantShare = _totalShares;\n        sharePrice = _sharePrice;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    function invest() public payable {\n        require(msg.value > 0, \"Investment amount must be greater than 0\");\n        uint256  percentage= (((msg.value)/(sharePrice * constantShare))*100)/1e18;\n        require(percentage > 0 && percentage <= 100, \"Percentage must be between 1 and 100\");\n\n\n        uint256 sharesToBuy = (constantShare * percentage)/100 ;\n        require(sharesToBuy <= totalShares, \"Not enough shares available\");\n\n        investors[msg.sender].investedAmount += msg.value;\n        investors[msg.sender].sharePercentage += percentage;\n\n        totalShares -= sharesToBuy;\n\n        // Add the investor address to the list\n        investorAddresses.push(msg.sender);\n        emit newInvestor(msg.sender, percentage);\n\n        \n    }\n\n\n        ///@notice This function takes in the serviceAmount and allow users that have recived service from the comapny\n        /// @notice to pay the company and the investors.\n    function payForService() public payable{ // anybody should be able to call this \n        // Calculate payments to investors and distribute\n       \n        for (uint256 i = 0; i < investorAddresses.length; i++) {\n            address investor = investorAddresses[i];\n            uint256 share = ((msg.value/1e18) * investors[investor].sharePercentage) / 100;\n            uint256 payout = (investors[investor].investedAmount * share) / totalCompanyValue;\n            \n            payable(investor).transfer(payout);\n\n            emit ServicePaymentProcessed(msg.value);\n        }\n        \n    }\n\n    function withdraw( uint _amount, address _address) public onlyOwner {\n        payable(_address).transfer(_amount);\n\n        \n        emit  withdrawSuccess(_amount, _address);\n    }\n\n    function checkBalance() public  view returns (uint256){\n        return  address(this).balance;\n\n    }\n\n    \n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}